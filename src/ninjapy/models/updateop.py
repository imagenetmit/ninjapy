"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from enum import Enum
from ninjapy.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from ninjapy.utils import FieldMetadata, PathParamMetadata, RequestMetadata
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class UpdateType(str, Enum):
    r"""Type of ticket"""

    PROBLEM = "PROBLEM"
    QUESTION = "QUESTION"
    INCIDENT = "INCIDENT"
    TASK = "TASK"


class UpdateCcTypedDict(TypedDict):
    uids: NotRequired[Nullable[List[Nullable[str]]]]
    r"""List of user uids to be carbon-copied"""
    emails: NotRequired[Nullable[List[Nullable[str]]]]
    r"""emails"""


class UpdateCc(BaseModel):
    uids: OptionalNullable[List[Nullable[str]]] = UNSET
    r"""List of user uids to be carbon-copied"""

    emails: OptionalNullable[List[Nullable[str]]] = UNSET
    r"""emails"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["uids", "emails"]
        nullable_fields = ["uids", "emails"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UpdateSeverity(str, Enum):
    NONE = "NONE"
    MINOR = "MINOR"
    MODERATE = "MODERATE"
    MAJOR = "MAJOR"
    CRITICAL = "CRITICAL"


class UpdatePriority(str, Enum):
    NONE = "NONE"
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"


class UpdateAttributesTypedDict(TypedDict):
    attribute_id: int
    r"""Attribute identifier"""
    value: str
    r"""Attribute value"""
    id: NotRequired[Nullable[int]]


class UpdateAttributes(BaseModel):
    attribute_id: Annotated[int, pydantic.Field(alias="attributeId")]
    r"""Attribute identifier"""

    value: str
    r"""Attribute value"""

    id: OptionalNullable[int] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["id"]
        nullable_fields = ["id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UpdateRequestBodyTypedDict(TypedDict):
    r"""UpdateTicket object that needs to be updated to the store"""

    version: int
    r"""ticket version"""
    client_id: int
    r"""Client (Organization) identifier"""
    ticket_form_id: int
    r"""Ticket form identifier"""
    subject: str
    requester_uid: str
    location_id: NotRequired[Nullable[int]]
    r"""Location identifier"""
    node_id: NotRequired[Nullable[int]]
    r"""Device identifier"""
    status: NotRequired[str]
    type: NotRequired[Nullable[UpdateType]]
    r"""Type of ticket"""
    cc: NotRequired[Nullable[UpdateCcTypedDict]]
    assigned_app_user_id: NotRequired[Nullable[int]]
    severity: NotRequired[Nullable[UpdateSeverity]]
    priority: NotRequired[Nullable[UpdatePriority]]
    parent_ticket_id: NotRequired[Nullable[int]]
    r"""Ticket parent identifier"""
    tags: NotRequired[Nullable[List[Nullable[str]]]]
    attributes: NotRequired[Nullable[List[Nullable[UpdateAttributesTypedDict]]]]


class UpdateRequestBody(BaseModel):
    r"""UpdateTicket object that needs to be updated to the store"""

    version: int
    r"""ticket version"""

    client_id: Annotated[int, pydantic.Field(alias="clientId")]
    r"""Client (Organization) identifier"""

    ticket_form_id: Annotated[int, pydantic.Field(alias="ticketFormId")]
    r"""Ticket form identifier"""

    subject: str

    requester_uid: Annotated[str, pydantic.Field(alias="requesterUid")]

    location_id: Annotated[
        OptionalNullable[int], pydantic.Field(alias="locationId")
    ] = UNSET
    r"""Location identifier"""

    node_id: Annotated[OptionalNullable[int], pydantic.Field(alias="nodeId")] = UNSET
    r"""Device identifier"""

    status: Optional[str] = "1000"

    type: OptionalNullable[UpdateType] = UNSET
    r"""Type of ticket"""

    cc: OptionalNullable[UpdateCc] = UNSET

    assigned_app_user_id: Annotated[
        OptionalNullable[int], pydantic.Field(alias="assignedAppUserId")
    ] = UNSET

    severity: OptionalNullable[UpdateSeverity] = UpdateSeverity.NONE

    priority: OptionalNullable[UpdatePriority] = UpdatePriority.NONE

    parent_ticket_id: Annotated[
        OptionalNullable[int], pydantic.Field(alias="parentTicketId")
    ] = UNSET
    r"""Ticket parent identifier"""

    tags: OptionalNullable[List[Nullable[str]]] = UNSET

    attributes: OptionalNullable[List[Nullable[UpdateAttributes]]] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "locationId",
            "nodeId",
            "status",
            "type",
            "cc",
            "assignedAppUserId",
            "severity",
            "priority",
            "parentTicketId",
            "tags",
            "attributes",
        ]
        nullable_fields = [
            "locationId",
            "nodeId",
            "type",
            "cc",
            "assignedAppUserId",
            "severity",
            "priority",
            "parentTicketId",
            "tags",
            "attributes",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UpdateRequestTypedDict(TypedDict):
    ticket_id: int
    request_body: UpdateRequestBodyTypedDict
    r"""UpdateTicket object that needs to be updated to the store"""


class UpdateRequest(BaseModel):
    ticket_id: Annotated[
        int,
        pydantic.Field(alias="ticketId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]

    request_body: Annotated[
        UpdateRequestBody,
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ]
    r"""UpdateTicket object that needs to be updated to the store"""


class UpdateStatusTypedDict(TypedDict):
    name: NotRequired[str]
    display_name: NotRequired[str]
    parent_id: NotRequired[int]
    status_id: NotRequired[int]


class UpdateStatus(BaseModel):
    name: Optional[str] = None

    display_name: Annotated[Optional[str], pydantic.Field(alias="displayName")] = None

    parent_id: Annotated[Optional[int], pydantic.Field(alias="parentId")] = None

    status_id: Annotated[Optional[int], pydantic.Field(alias="statusId")] = None


class UpdateTicketingType(str, Enum):
    PROBLEM = "PROBLEM"
    QUESTION = "QUESTION"
    INCIDENT = "INCIDENT"
    TASK = "TASK"


class UpdateTicketingPriority(str, Enum):
    NONE = "NONE"
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"


class UpdateTicketingSeverity(str, Enum):
    NONE = "NONE"
    MINOR = "MINOR"
    MODERATE = "MODERATE"
    MAJOR = "MAJOR"
    CRITICAL = "CRITICAL"


class UpdateSource(str, Enum):
    TECHNICIAN = "TECHNICIAN"
    EMAIL = "EMAIL"
    WEB_FORM = "WEB_FORM"
    HELP_REQUEST = "HELP_REQUEST"
    END_USER = "END_USER"
    CONDITION = "CONDITION"
    SCHEDULED_SCRIPT = "SCHEDULED_SCRIPT"
    ACTIVITY = "ACTIVITY"


class UpdateCcListTypedDict(TypedDict):
    uids: NotRequired[List[str]]
    emails: NotRequired[List[str]]


class UpdateCcList(BaseModel):
    uids: Optional[List[str]] = None

    emails: Optional[List[str]] = None


class UpdateValueTypedDict(TypedDict):
    pass


class UpdateValue(BaseModel):
    pass


class UpdateAttributeValuesTypedDict(TypedDict):
    id: NotRequired[int]
    attribute_id: NotRequired[int]
    value: NotRequired[UpdateValueTypedDict]


class UpdateAttributeValues(BaseModel):
    id: Optional[int] = None

    attribute_id: Annotated[Optional[int], pydantic.Field(alias="attributeId")] = None

    value: Optional[UpdateValue] = None


class UpdateResponseBodyTypedDict(TypedDict):
    r"""default response"""

    id: NotRequired[int]
    version: NotRequired[int]
    node_id: NotRequired[int]
    client_id: NotRequired[int]
    location_id: NotRequired[int]
    assigned_app_user_id: NotRequired[int]
    requester_uid: NotRequired[str]
    subject: NotRequired[str]
    status: NotRequired[UpdateStatusTypedDict]
    type: NotRequired[UpdateTicketingType]
    priority: NotRequired[UpdateTicketingPriority]
    severity: NotRequired[UpdateTicketingSeverity]
    ticket_form_id: NotRequired[int]
    source: NotRequired[UpdateSource]
    tags: NotRequired[List[str]]
    cc_list: NotRequired[UpdateCcListTypedDict]
    create_time: NotRequired[float]
    deleted: NotRequired[bool]
    attribute_values: NotRequired[List[UpdateAttributeValuesTypedDict]]


class UpdateResponseBody(BaseModel):
    r"""default response"""

    id: Optional[int] = None

    version: Optional[int] = None

    node_id: Annotated[Optional[int], pydantic.Field(alias="nodeId")] = None

    client_id: Annotated[Optional[int], pydantic.Field(alias="clientId")] = None

    location_id: Annotated[Optional[int], pydantic.Field(alias="locationId")] = None

    assigned_app_user_id: Annotated[
        Optional[int], pydantic.Field(alias="assignedAppUserId")
    ] = None

    requester_uid: Annotated[Optional[str], pydantic.Field(alias="requesterUid")] = None

    subject: Optional[str] = None

    status: Optional[UpdateStatus] = None

    type: Optional[UpdateTicketingType] = None

    priority: Optional[UpdateTicketingPriority] = None

    severity: Optional[UpdateTicketingSeverity] = None

    ticket_form_id: Annotated[Optional[int], pydantic.Field(alias="ticketFormId")] = (
        None
    )

    source: Optional[UpdateSource] = None

    tags: Optional[List[str]] = None

    cc_list: Annotated[Optional[UpdateCcList], pydantic.Field(alias="ccList")] = None

    create_time: Annotated[Optional[float], pydantic.Field(alias="createTime")] = None

    deleted: Optional[bool] = None

    attribute_values: Annotated[
        Optional[List[UpdateAttributeValues]], pydantic.Field(alias="attributeValues")
    ] = None
